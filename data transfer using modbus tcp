#include <Arduino.h>
#include "ModbusClientRTU.h"
#include "Logging.h"
#include <SPI.h>
#include "FS.h" 
// #include <WiFiClient.h> 
#include "ThingSpeak.h" 
#include <ETH.h>      
#include "SPIFFS.h"

// Definitions for this special case
#define RXPIN 16
#define TXPIN 17
#define REDEPIN 2
#define BAUDRATE 9600
#define FIRST_REGISTER 1
#define NUM_VALUES 2
#define READ_INTERVAL 10000 // Change to read every 10 seconds
#define SLAVE_ID 1
#define SENSOR1 1

uint32_t request_time;

// Storage for register values
uint16_t registerValues[NUM_VALUES];

ModbusClientRTU MB(REDEPIN);

// Ethernet settings
#define ETH_PHY_TYPE ETH_PHY_LAN8720
#define ETH_PHY_ADDR 0
#define ETH_PHY_MDC 23
#define ETH_PHY_MDIO 18
#define ETH_PHY_POWER -1
#define ETH_CLK_MODE ETH_CLOCK_GPIO0_IN

static bool eth_connected = false;

// ThingSpeak settings
const unsigned long channelID = 25348; // Change to your ThinkSpeak Channel ID
const char *apiKey = "LL9SIRA1JKW"; // Change to your ThingSpeak API key

WiFiClient client; // Declare WiFiClient globally

// Function prototypes
void sendToThingSpeak(int value1, int value2);
void storeData(int value1, int value2);
void sendDataIfOnline();
void onEvent(WiFiEvent_t event);
void testClient(const char *host, uint16_t port);

// Event handler for Ethernet events
void onEvent(WiFiEvent_t event) {
  switch (event) {
    case ARDUINO_EVENT_ETH_START:
      Serial.println("ETH Started");
      ETH.setHostname("esp32-ethernet");
      break;
    case ARDUINO_EVENT_ETH_CONNECTED:
      Serial.println("ETH Connected");
      break;
    case ARDUINO_EVENT_ETH_GOT_IP:
      Serial.println("ETH Got IP");
      Serial.println(ETH.localIP());
      eth_connected = true;
      break;
    case ARDUINO_EVENT_ETH_DISCONNECTED:
      Serial.println("ETH Disconnected");
      eth_connected = false;
      break;
    case ARDUINO_EVENT_ETH_STOP:
      Serial.println("ETH Stopped");
      eth_connected = false;
      break;
    default:
      break;
  }
}

void handleData(ModbusMessage response, uint32_t token) {
  if (token == SENSOR1) {
    // Extract the register values from the response
    for (uint8_t i = 0; i < NUM_VALUES; ++i) {
      uint16_t value;
      response.get(3 + i * 2, value); // Get the value at the specified index
      registerValues[i] = value;
    }

    // Print the register values
    for (uint8_t i = 0; i < NUM_VALUES; ++i) {
      Serial.printf("Register %d value: %d\n", FIRST_REGISTER + i, registerValues[i]);
    }

    // Send data to ThingSpeak or store it if offline
    if (eth_connected) {
      sendToThingSpeak(registerValues[0], registerValues[1]);
    } else {
      storeData(registerValues[0], registerValues[1]);
    }
  }
}

void handleError(Error error, uint32_t token) {
  ModbusError me(error);
  LOG_E("Error response: %02X - %s\n", (int)me, (const char *)me);
  if (token == SENSOR1) {
    if (error == TIMEOUT) {
      Serial.println("Timeout");
    } else {
      Serial.println("Error");
    }
  }
}

void setup() {
  Serial.begin(115200);
  while (!Serial) {
  }
  Serial.println("__ OK __");

  if (!SPIFFS.begin(true)) {
    Serial.println("An error has occurred while mounting SPIFFS");
    return;
  }

  RTUutils::prepareHardwareSerial(Serial1);
  Serial1.begin(BAUDRATE, SERIAL_8N1, RXPIN, TXPIN);

  MB.onDataHandler(&handleData);
  MB.onErrorHandler(&handleError);
  MB.setTimeout(3000);
  MB.begin(Serial1);

  // Initialize Ethernet
  WiFi.onEvent(onEvent);
  ETH.begin();

  // Initialize ThingSpeak
  ThingSpeak.begin(client);
}

void loop() {
  static unsigned long next_request = millis();

  if (millis() - next_request > READ_INTERVAL) {
    Error err = MB.addRequest(SENSOR1, SLAVE_ID, READ_HOLD_REGISTER, FIRST_REGISTER, NUM_VALUES);
    if (err != SUCCESS) {
      ModbusError e(err);
      LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);
      Serial.println("\nrequest error\n");
    }
    next_request = millis();
  }

  // Attempt to send stored data if online
  if (eth_connected) {
    sendDataIfOnline();
  }

  delay(10000); // Delay for 10 seconds
}

void sendToThingSpeak(int value1, int value2) {
  // Write to ThingSpeak
  ThingSpeak.setField(1, value1);
  ThingSpeak.setField(2, value2);
  if (ThingSpeak.writeFields(channelID, apiKey) == 200) {
    Serial.println("Data sent to ThingSpeak successfully");
  } else {
    Serial.println("Failed to send data to ThingSpeak");
  }
}

void storeData(int value1, int value2) {
  File dataFile = SPIFFS.open("/data.txt", "a");
  if (!dataFile) {
    Serial.println("Failed to open file for appending");
    return;
  }
  dataFile.printf("%d,%d\n", value1, value2);
  dataFile.close();
  Serial.println("Data stored locally");
}

void sendDataIfOnline() {
  File dataFile = SPIFFS.open("/data.txt", "r");
  if (!dataFile) {
    Serial.println("Failed to open file for reading");
    return;
  }

  while (dataFile.available()) {
    String line = dataFile.readStringUntil('\n');
    int commaIndex = line.indexOf(',');
    if (commaIndex > 0) {
      int value1 = line.substring(0, commaIndex).toInt();
      int value2 = line.substring(commaIndex + 1).toInt();
      sendToThingSpeak(value1, value2);
    }
  }

  dataFile.close();
  SPIFFS.remove("/data.txt");
}

void testClient(const char *host, uint16_t port) {
  Serial.print("\nconnecting to ");
  Serial.println(host);

  WiFiClient client;
  if (!client.connect(host, port)) {
    Serial.println("connection failed");
    return;
  }
  client.printf("GET / HTTP/1.1\r\nHost: %s\r\n\r\n", host);
  while (client.connected() && !client.available());
  while (client.available()) {
    Serial.write(client.read());
  }

  Serial.println("closing connection\n");
  client.stop();
}
